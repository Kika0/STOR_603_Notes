---
title: "Explore extremes"
format: html
---

```{r}
#| echo: false
#| message: false
#| warning: false
library(tidyverse)
library(latex2exp)
library(ismev)
library(gridExtra)
source("gev_fit.R")
theme_set(theme_minimal())
theme_update(plot.title = element_text(hjust = 0.5))
```

## Block maxima

Suppose we generate from normal distribution. And we have block maxima from every $100$ observations.

```{r}
df <- data.frame(x=1:10000, y=rnorm(10000,0,1))
df$block_max <- rep(FALSE,10000)
for (i in 1:100) {
  df$block_max[df$y==(max(df$y[(100*(i-1)+1):(100*i)]))] <- TRUE
}
ggplot(df) + geom_point(aes(x=x,y=y,colour=factor(block_max)))
```

Suppose we plot only the block maxima.

```{r}
ggplot(df %>% filter(block_max==TRUE)) + geom_point(aes(x=x,y=y))
```

Model with GEV.

```{r}
ggplot(df %>% filter(block_max==TRUE),aes(y)) + geom_density()
```

```{r}
ggplot(df,aes(y) ) + geom_density()
```

### Return level plots

Exercise recreating Fig. 3.1 from Coles' book. Possible typo in the book as the $x$-axis should be $- \log(-\log(U))$ and not $\log(-\log(U))$.

```{r}
# set parameters
mu <- rep(0,3)
sigma <- rep(1,3)
xi <- c(-0.2,0,0.2)
U <- runif(10000) %>% sort()
z_p_neg <- c()
z_p_pos <- c()
z_p_0 <- c()
# calculate z_p for different values of xi
for (i in 1:length(U)) {
  z_p_neg[i] <-  -(1- (-log(U[i]))^(-xi[1])  )*(sigma[1]/xi[1])+ mu[1]
  z_p_pos[i] <-  -(1- (-log(U[i]))^(-xi[3])  )*(sigma[3]/xi[3])+ mu[3]
  z_p_0[i] <- -log(-log(U[i]))*sigma[2]+mu[2]
}
z_p <- data.frame(U,z_p_neg,z_p_0,z_p_pos)
z_p %>% ggplot() + geom_line(aes(x=-log(-log(U)),y=(z_p_neg)),color="#009ada",size=1.5) + geom_line(aes(x=-log(-log(U)),y=(z_p_0)),size=1.5) + geom_line(aes(x=-log(-log(U)),y=(z_p_pos)),color="#c11432",size=1.5) + 
  xlab(TeX("$-\\log(-\\log(U))$")) +
  ylab(TeX("$z_p$" )) + theme_minimal() +
  annotate("text", x = 8, y = 0, label = TeX("$\\xi=-.2$")) +
  annotate("text", x = 8, y = 10, label = TeX("$\\xi=0$")) +
  annotate("text", x = 8, y = 25, label = TeX("$\\xi=.2$"))
```

### Maximum likelihood fitting of the GEV distribution

```{r}
data(venice)
```

Try some functions from the `ismev` package.

```{r}
gev.fit(venice[,2])
```

Try random exponential as it is known to have $\xi=0$.

```{r}
df <- data.frame(x=1:10000, y=rnorm(10000,0,1))
df$block_max <- rep(FALSE,10000)
for (i in 1:100) {
  df$block_max[df$y==(max(df$y[(100*(i-1)+1):(100*i)]))] <- TRUE
}
ggplot(df) + geom_point(aes(x=x,y=y,colour=factor(block_max)))

```

```{r}

fit <- gev.fit(df$y[df$block_max==TRUE])
fit$mle

#gamGPDfit(x=df,datvar='y',threshold = 2.5,xiFrhs = xiFrhs)
```

Compare the fit with the density.

```{r}
g <- function(x) {
  1/fit$mle[2] * (1 + fit$mle[3]*((x - fit$mle[1])/fit$mle[2] )   )^(-(1+1/fit$mle[3]))* exp(-(1 + fit$mle[3]*((x - fit$mle[1])/fit$mle[2] )   )^(-1/fit$mle[3]) )
}
x_fit <- seq(1,4,0.01)
y_fit <- c()
for (i in 1:length(x_fit)) {
  y_fit[i] <- g(x_fit[i])
}
#plot(x_fit,y_fit)
df_fit <- data.frame(x_fit,y_fit)
```

```{r}
ggplot() + geom_density(df %>% filter(block_max==TRUE),mapping=aes(y)) + geom_line(df_fit,mapping = aes(x_fit,y_fit),color='#c11432') + theme_minimal()
```

Try same fit with Venice data.

```{r}
venice <- data.frame(x=1:length(venice[,2]),y=venice[,2])
fit <- gev.fit(df$y[df$block_max==TRUE])
fit$mle
x_fit <- seq(70,200,1)
y_fit <- c()
g <- function(x) {
  1/fit$mle[2] * (1 + fit$mle[3]*((x - fit$mle[1])/fit$mle[2] )   )^(-(1+1/fit$mle[3]))* exp(-(1 + fit$mle[3]*((x - fit$mle[1])/fit$mle[2] )   )^(-1/fit$mle[3]) )
}
for (i in 1:length(x_fit)) {
  y_fit[i] <- g(x_fit[i])
}
df_fit <- data.frame(x_fit,y_fit)
ggplot() + geom_density(venice,mapping=aes(y)) + geom_line(df_fit,mapping = aes(x_fit,y_fit),color='#c11432') + theme_minimal()

```

```{r}
N <- 1000
norm <- rnorm(N)
ex <- rexp(N)

plot(norm,ex)

hist(norm)
hist(ex)

u_1 <- pnorm(norm)
u_2 <- pexp(ex)

u_1 %>% head()
plot(u_1,u_2)

n_1 <- qnorm(u_1)
n_2 <- qnorm(u_2)
plot(n_1,n_2)

par_1 <- 1/(1-u_1)
par_2 <- 1/(1-u_2)
plot(par_1,par_2)
```

## Plot Gumbel distribution using PIT

```{r}
mu <- 1
sig <- 1
U <- runif(1000)
z <- mu - sig*log(-log(U))
df <- data.frame(z,U)
ggplot(df) + geom_point(aes(x=z,y=U))
```

## Try Port Pirie sea-levels diagnostic plots

Port Pirie data not available in the package, maybe try with Venice sea-levels data?

```{r}
data(portpirie)
venice[,2]
x=gev.fit(portpirie[,2])
gev.diag(x)
```

Try to recreate the likelihood function.

```{r}
x <- portpirie[,2]
```

The function gets longer as initial values of the parameters are either pre-specified or calculated from the data. Therefore, `gev_fit.R` script contains the function.

```{r}
gev.diag(gev_fit(x))
# the function could return very high values 
# that cannot be minimum negative likelihood like 10^6
# would include in further development
```

Success! The plotting function works with the likelihood function and produces desired output.

### GEV plot outputs

Now, try to replicate the four plots given above, starting with the probability plot. The model probability is a straight line, but empirical data will deviate from this line.

```{r}
# calculate GEV inverse CDF
GEV_inv <- function(U,mle) {
  mu <- mle[1]
  sig <- mle[2]
  xi <- mle[3]
 z <-  (sig/xi) * (  (-log(U))^(-xi) -1) + mu 
 return(z)
}
# calculate GEV CDF
GEV <- function(z,mle) {
  mu <- mle[1]
  sig <- mle[2]
  xi <- mle[3]
  G <- c()
  for (i in 1:length(z))
 G[i] <- exp(  -(1 + xi*((z[i]-mu)/sig) )^(-1/xi)  )
 return(G)
}
mle <- gev_fit(x)$mle
Model <- portpirie %>% select(SeaLevel) %>% mutate(Model=GEV(z=SeaLevel,mle=mle))
Empirical <- portpirie %>% select(SeaLevel) %>% arrange(SeaLevel) %>% mutate(Empirical=row_number()/(nrow(portpirie)+1)) 
df <- portpirie %>% left_join(Empirical,by="SeaLevel") %>% left_join(Model,by="SeaLevel")
df %>% head()
df %>% ggplot()  + geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), color = "#C11432",size=1.5)+ geom_point(aes(x=Empirical,y=Model)) + ggtitle("Probability Plot") + xlab("Empirical distribution") + ylab("Model distribution")
```

Next is Q-Q plot.Q-Q plot compares two probability distributions by plotting their quantiles. In this example, it plots two GEV distributions with different parameters: empirical calculated though a formula used for the initial parameters in the optimisation and the model parameters (MLE).

```{r}
GEV_QQ <- function(x) {
  
# empirical distribution estimates
    sig_init <- sqrt(6 * var(x))/pi
    mu_init <- mean(x) - 0.57722 * sig_init
    xi_init <- 0.1
est_par <- c(mu_init,sig_init,xi_init)
# model (MLE) estimates
model_par <- gev_fit(x)$mle
# generate z using PIT for each case
q <- seq(from=1/(length(x)+1),to=length(x)/(length(x)+1),length.out=length(x)) #quantile
model <- GEV_inv(U=q,mle=model_par) #z generated from the model
est <- GEV_inv(U=q,mle=est_par) #z generated from GEV empirical estimates
dat <- x %>% sort()
return(data.frame(q=q,Model=model,Empirical=est,Data=dat))
}
# plot
df <- GEV_QQ(portpirie[,2])
df %>% head()
df %>% ggplot()  + 
  geom_segment(aes(x = 3.5, y = 3.5, xend = 4.9, yend = 4.9), color = "#C11432",size=1.5,alpha=0.5)+
  geom_point(aes(x=Empirical,y=Model)) + ggtitle("Q-Q Plot (from empirical estimates, not data)") + xlab("Empirical") + ylab("Model") 
```

The plot shows that empirical estimates are good since it is almost linear but shape parameter is a bit off, hence the slight curve.

```{r}
df %>% ggplot()  + 
  geom_segment(aes(x = 3.5, y = 3.5, xend = 4.75, yend = 4.75), color = "#C11432",size=1.5,alpha=0.5)+
  geom_point(aes(y=Data,x=Model)) + ggtitle("Quantile Plot ") + ylab("Empirical") + xlab("Model")
```

The next plot is return level plot.

```{r}
### calculate 10 year return level ----
fit <- gev_fit(x)
r <- 10
# # calculate z
# z <- GEV_inv(U=(1-1/r),mle=fit$mle)
# # calculate variance
# var_calc <- function(p,par) {
# mu <- fit$mle[1]
# sig <- fit$mle[2]
# xi <- fit$mle[3]
# 
# z <- c(1)
# var <- z_T*Cov*z
# }
# 
# 
 p <- seq(0.99,0.01,-0.01)
# var <- var_calc(p=p,par=fit$mle)
# # calculate the CI
# CI_l <- z-qnorm(0.975)*var
# CI_u <- z+qnorm(0.975)*var
z <- GEV_inv(U=p,mle=fit$mle)
df <- data.frame(p,z)
x <- portpirie[,2]
q <- seq(from=1/(length(x)+1),to=length(x)/(length(x)+1),length.out=length(x)) #quantile
dat <- x %>% sort()

df1 <- data.frame(dat,q)
df %>% head()
ggplot() + 
  geom_line(aes(x=-1/log(df$p),y=df$z)) +
  geom_point(aes(x=-1/log(df1$q),y=df1$dat)) + coord_trans(x="log") + xlab("Return level in years?")
plot(-1/log((1:length(dat))/(length(dat) + 1)), sort(dat),log='x')

```

```{r}
N <- 1000
U_1 <- runif(N)
X_1 <- -1/(log(U_1))
U_2 <- runif(N)
X_2 <- -1/(log(U_2))
plot(X_1/1000,X_2/1000)


R <- X_1/N+X_2/N
W <- (X_1/N)/(R)
plot(R,W)
X_3 <- X_1[R>0.1]
W_1 <- W[R>0.01]
R_1 <- R[R>0.01]
plot(R_1,W_1)
```

### 5.2 Maxima of stationary sequences

Simulate series $X_i=\max (Y_{i-1}, Y_i)$ where $Y$ has cdf $F_Y(y)= \exp \left\{ -\frac{1}{(a+1)y} \right\}$ for different values of $a$.

```{r}
# set a
a <- 0
# generate from Y
U <- runif(50)
Y <- c()
for (i in 1:50) {
Y[i] <- -1/(log(U[i])*(a+1))  
}
X <- Y[1]
for (i in 2:50) {
  X[i] <- max(Y[i-1],Y[i])
}
df <- data.frame(X,Y,ite=1:50)
x <- ggplot(df) + geom_point(aes(x=ite, y=X))
y <- ggplot(df) + geom_point(aes(x=ite, y=Y))
grid.arrange(x,y,ncol=2)
```

```{r}
# set a
a <- 1/3
# generate from Y
U <- runif(50)
Y <- c()
for (i in 1:50) {
Y[i] <- -1/(log(U[i])*(a+1))  
}
X <- Y[1]
for (i in 2:50) {
  X[i] <- max(Y[i-1],Y[i])
}
df <- data.frame(X,Y,ite=1:50)
x <- ggplot(df) + geom_point(aes(x=ite, y=X))
y <- ggplot(df) + geom_point(aes(x=ite, y=Y))
grid.arrange(x,y,ncol=2)
```

```{r}
# set a
a <- 2/3
# generate from Y
U <- runif(50)
Y <- c()
for (i in 1:50) {
Y[i] <- -1/(log(U[i])*(a+1))  
}
X <- Y[1]
for (i in 2:50) {
  X[i] <- max(Y[i-1],Y[i])
}
df <- data.frame(X,Y,ite=1:50)
x <- ggplot(df) + geom_point(aes(x=ite, y=X))
y <- ggplot(df) + geom_point(aes(x=ite, y=Y))
grid.arrange(x,y,ncol=2)
```

```{r}
# set a
a <- 1
# generate from Y
U <- runif(50)
Y <- c()
for (i in 1:50) {
Y[i] <- -1/(log(U[i])*(a+1))  
}
X <- Y[1]
for (i in 2:50) {
  X[i] <- max(Y[i-1],Y[i])
}
df <- data.frame(X,Y,ite=1:50)
x <- ggplot(df) + geom_point(aes(x=ite, y=X))
y <- ggplot(df) + geom_point(aes(x=ite, y=Y))
grid.arrange(x,y,ncol=2)
ggplot(df) + geom_point(aes(x=X, y=Y))
```

This makes sense. For example, $z=1$ corresponds to `r exp(-1/(1))` for $a=0$ and `r exp(-1/2)` for $a=1$. Because the quantile is lower for $a=0$, the distribution has more values larger then $1$ than the case when $a=1$.

### Extend the idea to a series of coefficients

Define $X_1=\max \left\{ a_1Y_1,a_2Y_2,\dots, a_dY_d \right\}$ and $X_2=\max \left\{ b_1Y_1,b_2Y_2,\dots, b_dY_d \right\}$. Further assume that $Y_i$ are independent with FrÃ©chet distribution. Varying parameters are length $d$ taking max over, sequences $a$ and $b$.

```{r}
d=5
# generate Y
Y <- c()
for (i in 1:50) {
Y[i] <- -1/(log(U[i])*(a+1))  
}
X[1:(d-1)] <- Y[1:(d-1)]
for (i in d:50) {
  X[i] <- max(Y[(i-(d-1)):i])
}

df <- data.frame(X,Y,ite=1:50)
x <- ggplot(df) + geom_point(aes(x=ite, y=X))
y <- ggplot(df) + geom_point(aes(x=ite, y=Y))
grid.arrange(x,y,ncol=2)
# define a_1,...,a_50
#a_seq <- seq(1,0.1,length.out=50)
# define b_1,...,b_50
#b_seq <- seq(1,0.5,length.out=50)
ggplot(df) + geom_point(aes(x=X, y=Y))
```
Try different values of $d$.
```{r}
set.seed(1)
d <- 3
N <- 50
U <- runif(d*N)
a <- rep(1/3,d)
b <- (1:3)/6
# generate Y
Y <- c()
Y <- -1/(log(U) ) 

# generate X
X_1 <- c()
X_2 <- c()

for (j in 1:N) {
X_1[j] <- max(Y[(d*(j-1)+1):(d*j)]*a)/N
X_2[j] <- max(Y[(d*(j-1)+1):(d*j)]*b)/N
}

# it is better to plot X_1/N against X_2/N
plot(X_1,X_2)
df1 <- data.frame(X_1=X_1,X_2=X_2,uni=seq(0.02,1,0.02),
             uni_3=  seq(0.02,5/6,length.out=50), 
             u_x=seq(0,0.1,length.out=50),
             u_y=0.1-seq(0,0.1,length.out=50),
             line_1=seq(0.02,1,0.02)*(1/2),line_2=seq(0.02,1,0.02)*(1),line_3=seq(0.02,5/6,length.out=50)*(3/2))
df1 <-df1 %>%  mutate(above_u=(X_1+X_2>0.1)) %>% mutate(N=rep(paste0("n=",nrow(df1)),nrow(df1)))

### repeat for larger sample size
N <- 50000
U <- runif(d*N)
a <- rep(1/3,d)
b <- (1:3)/6
# generate Y
Y <- c()
Y <- -1/(log(U) ) 

# generate X
X_1 <- c()
X_2 <- c()

for (j in 1:N) {
X_1[j] <- max(Y[(d*(j-1)+1):(d*j)]*a)/N
X_2[j] <- max(Y[(d*(j-1)+1):(d*j)]*b)/N
}
df2 <- data.frame(X_1=X_1,X_2=X_2,uni=seq(0.02,1,length.out=N),
             uni_3=  seq(0.02,5/6,length.out=N), 
             u_x=seq(0,0.1,length.out=N),
             u_y=0.1-seq(0,0.1,length.out=N),
             line_1=seq(0.02,1,length.out=N)*(1/2),line_2=seq(0.02,1,length.out=N)*(1),line_3=seq(0.02,5/6,length.out=N)*(3/2))
df2 <-df2 %>%  mutate(above_u=(X_1+X_2>0.1)) %>% mutate(N=rep(paste0("n=",nrow(df2)),nrow(df2)))

df_bind <- rbind(df1,df2) %>% mutate(N=as.factor(N))

ggplot(df_bind) + geom_point(aes(x=X_1, y=X_2,col=above_u),alpha=0.5) +
  scale_color_manual(values = c("TRUE" = "black",
                                "FALSE"="#C11432")) +
   labs(color=TeX('Above threshold $u$')) +
  xlab(TeX("$X_1/n$")) + ylab(TeX("$X_2/n$"))+
  geom_line(aes(x=uni,y=line_1),alpha=0.3) +
    geom_line(aes(x=uni,y=line_2),alpha=0.3) +
    geom_line(aes(x=uni_3,y=line_3),alpha=0.3) +
   geom_line(aes(x=u_x,y=u_y),col="#C11432",alpha=0.6,linetype="dashed") +
  annotate("text",x=0.12,y=0.05,label="u",col="#C11432") +
  coord_fixed()+ facet_wrap(vars(N))   +
  theme_bw() +
  theme(panel.spacing = unit(2, "lines"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black", fill = NA))
```
Plot only above threshold?

Plot radial and angular components.

```{r}
df3 <- data.frame(r=(df1$X_1+df1$X_2),w=df1$X_1/(df1$X_1+df1$X_2),above_u=df1$above_u)%>% mutate(N=rep(paste0("n=",nrow(df1)),nrow(df1))) %>% 
  mutate(u_x=seq(0,1,length.out=nrow(df1))) %>% 
  mutate(u_y=rep(0.1,nrow(df1)))

df4 <- data.frame(r=(df2$X_1+df2$X_2),w=df2$X_1/(df2$X_1+df2$X_2),above_u=df2$above_u)%>% mutate(N=rep(paste0("n=",nrow(df2)),nrow(df2))) %>% 
   mutate(u_x=seq(0,1,length.out=nrow(df2))) %>% 
  mutate(u_y=rep(0.1,nrow(df2)))
df_bind <- rbind(df3,df4)

ggplot(df_bind) + geom_point(data=df_bind,aes(x=w,y=log(r),col=above_u),alpha=0.5)+
  geom_line(data=df_bind,aes(x=u_x,y=log(u_y)),col="#C11432",alpha=0.6,linetype="dashed") +
  annotate("segment",x=0.4,xend=0.4,y=min(log(df_bind$r))-0.2,yend=max(log(df_bind$r))+0.2,alpha=0.3) +
    annotate("segment",x=1/2,xend=1/2,y=min(log(df_bind$r))-0.2,yend=max(log(df_bind$r))+0.2,alpha=0.3) +
    annotate("segment",x=2/3,xend=2/3,y=min(log(df_bind$r))-0.2,yend=max(log(df_bind$r))+0.2,alpha=0.3) +
  annotate("text",x=1,y=-2.7,label="u",col="#C11432") +
scale_color_manual(values = c("TRUE" = "black",
                                "FALSE"="#C11432")) +
   labs(color=TeX('Above threshold $u$')) +
facet_wrap(vars(N)) + 
    theme_bw() +
  theme(panel.spacing = unit(2, "lines"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank(),
        panel.border = element_rect(colour = "black", fill = NA))
```

 
### Transformation to Gumbel margins

Use PIT to transform Port Pirie data to have Gumbel margins (as motivated by Heffernan and Tawn (2004)).

```{r}
# create x and y quantile variables
U <- portpirie %>% select(SeaLevel,Year) %>% arrange(SeaLevel) %>% mutate(u=row_number()/(nrow(portpirie)+1))
# generate Gumbel margins

df <- portpirie %>% left_join((U %>% select(Year,u)),by="Year") 
df <- df %>% mutate(Gumbel=-log(-log(u)))
df %>% head()

ggplot(df)+ geom_point(aes(x=Year,y=SeaLevel)) + geom_point(aes(x=Year,y=u),col="#C11432") +
  geom_point(aes(x=Year,y=Gumbel),col="#009ADA") +
  theme(aspect.ratio = 1) + xlab("Year") + ylab("Maximum Sea Level")
```



