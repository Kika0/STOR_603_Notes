---
title: "Explore extremes"
format: html
---

```{r}
#| echo: false
#| message: false
#| warning: false
library(tidyverse)
library(latex2exp)
library(ismev)
source("gev_fit.R")
theme_set(theme_minimal())
theme_update(plot.title = element_text(hjust = 0.5))
```

## Block maxima 

Suppose we generate from normal distribution. And we have block maxima from every $100$ observations.

```{r}
df <- data.frame(x=1:10000, y=rnorm(10000,0,1))
df$block_max <- rep(FALSE,10000)
for (i in 1:100) {
  df$block_max[df$y==(max(df$y[(100*(i-1)+1):(100*i)]))] <- TRUE
}
ggplot(df) + geom_point(aes(x=x,y=y,colour=factor(block_max)))
```
Suppose we plot only the block maxima.

```{r}
ggplot(df %>% filter(block_max==TRUE)) + geom_point(aes(x=x,y=y))
```
Model with GEV.

```{r}
ggplot(df %>% filter(block_max==TRUE),aes(y)) + geom_density()
```

```{r}
ggplot(df,aes(y) ) + geom_density()
```
### Return level plots

Exercise recreating Fig. 3.1 from Coles' book. Possible typo in the book as the $x$-axis should be $- \log(-\log(U))$ and not $\log(-\log(U))$.

```{r}
# set parameters
mu <- rep(0,3)
sigma <- rep(1,3)
xi <- c(-0.2,0,0.2)
U <- runif(10000) %>% sort()
z_p_neg <- c()
z_p_pos <- c()
z_p_0 <- c()
# calculate z_p for different values of xi
for (i in 1:length(U)) {
  z_p_neg[i] <-  -(1- (-log(U[i]))^(-xi[1])  )*(sigma[1]/xi[1])+ mu[1]
  z_p_pos[i] <-  -(1- (-log(U[i]))^(-xi[3])  )*(sigma[3]/xi[3])+ mu[3]
  z_p_0[i] <- -log(-log(U[i]))*sigma[2]+mu[2]
}
z_p <- data.frame(U,z_p_neg,z_p_0,z_p_pos)
z_p %>% ggplot() + geom_line(aes(x=-log(-log(U)),y=(z_p_neg)),color="#009ada",size=1.5) + geom_line(aes(x=-log(-log(U)),y=(z_p_0)),size=1.5) + geom_line(aes(x=-log(-log(U)),y=(z_p_pos)),color="#c11432",size=1.5) + 
  xlab(TeX("$-\\log(-\\log(U))$")) +
  ylab(TeX("$z_p$" )) + theme_minimal() +
  annotate("text", x = 8, y = 0, label = TeX("$\\xi=-.2$")) +
  annotate("text", x = 8, y = 10, label = TeX("$\\xi=0$")) +
  annotate("text", x = 8, y = 25, label = TeX("$\\xi=.2$"))
```



### Maximum likelihood fitting of the GEV distribution

```{r}
data(venice)
```

Try some functions from the `ismev` package.

```{r}
gev.fit(venice[,2])
```
Try random exponential as it is known to have $\xi=
```{r}
df <- data.frame(x=1:10000, y=rnorm(10000,0,1))
df$block_max <- rep(FALSE,10000)
for (i in 1:100) {
  df$block_max[df$y==(max(df$y[(100*(i-1)+1):(100*i)]))] <- TRUE
}
ggplot(df) + geom_point(aes(x=x,y=y,colour=factor(block_max)))

```
```{r}

fit <- gev.fit(df$y[df$block_max==TRUE])
fit$mle

#gamGPDfit(x=df,datvar='y',threshold = 2.5,xiFrhs = xiFrhs)
```
Compare the fit with the density.

```{r}
g <- function(x) {
  1/fit$mle[2] * (1 + fit$mle[3]*((x - fit$mle[1])/fit$mle[2] )   )^(-(1+1/fit$mle[3]))* exp(-(1 + fit$mle[3]*((x - fit$mle[1])/fit$mle[2] )   )^(-1/fit$mle[3]) )
}
x_fit <- seq(1,4,0.01)
y_fit <- c()
for (i in 1:length(x_fit)) {
  y_fit[i] <- g(x_fit[i])
}
#plot(x_fit,y_fit)
df_fit <- data.frame(x_fit,y_fit)
```


```{r}
ggplot() + geom_density(df %>% filter(block_max==TRUE),mapping=aes(y)) + geom_line(df_fit,mapping = aes(x_fit,y_fit),color='#c11432') + theme_minimal()
```
Try same fit with Venice data.

```{r}
venice <- data.frame(x=1:length(venice[,2]),y=venice[,2])
fit <- gev.fit(df$y[df$block_max==TRUE])
fit$mle
x_fit <- seq(70,200,1)
y_fit <- c()
g <- function(x) {
  1/fit$mle[2] * (1 + fit$mle[3]*((x - fit$mle[1])/fit$mle[2] )   )^(-(1+1/fit$mle[3]))* exp(-(1 + fit$mle[3]*((x - fit$mle[1])/fit$mle[2] )   )^(-1/fit$mle[3]) )
}
for (i in 1:length(x_fit)) {
  y_fit[i] <- g(x_fit[i])
}
df_fit <- data.frame(x_fit,y_fit)
ggplot() + geom_density(venice,mapping=aes(y)) + geom_line(df_fit,mapping = aes(x_fit,y_fit),color='#c11432') + theme_minimal()

```

```{r}
N <- 1000
norm <- rnorm(N)
ex <- rexp(N)

plot(norm,ex)

hist(norm)
hist(ex)

u_1 <- pnorm(norm)
u_2 <- pexp(ex)

u_1 %>% head()
plot(u_1,u_2)

n_1 <- qnorm(u_1)
n_2 <- qnorm(u_2)
plot(n_1,n_2)

par_1 <- 1/(1-u_1)
par_2 <- 1/(1-u_2)
plot(par_1,par_2)
```
## Plot Gumbel distribution using PIT

```{r}
mu <- 1
sig <- 1
U <- runif(1000)
z <- mu - sig*log(-log(U))
df <- data.frame(z,U)
ggplot(df) + geom_point(aes(x=z,y=U))
```
## Try Port Pirie sea-levels diagnostic plots

Port Pirie data not available in the package, maybe try with Venice sea-levels data?

```{r}
data(portpirie)
venice[,2]
x=gev.fit(portpirie[,2])
gev.diag(x)
```
Try to recreate the likelihood function.

```{r}
x <- portpirie[,2]
```

The function gets longer as initial values of the parameters are either pre-specified or calculated from the data. Therefore, `gev_fit.R` script contains the function.

```{r}
gev.diag(gev_fit(x))
# the function could return very high values 
# that cannot be minimum negative likelihood like 10^6
# would include in further development
```
Success! The plotting function works with the likelihood function and produces desired output.

### GEV plot outputs

Now, try to replicate the four plots given above, starting with the probability plot. The model probability is a straight line, but empirical data will deviate from this line.

```{r}
# calculate GEV inverse CDF
GEV_inv <- function(U,mle) {
  mu <- mle[1]
  sig <- mle[2]
  xi <- mle[3]
 z <-  (sig/xi) * (  (-log(U))^(-xi) -1) + mu 
 return(z)
}
# calculate GEV CDF
GEV <- function(z,mle) {
  mu <- mle[1]
  sig <- mle[2]
  xi <- mle[3]
  G <- c()
  for (i in 1:length(z))
 G[i] <- exp(  -(1 + xi*((z[i]-mu)/sig) )^(-1/xi)  )
 return(G)
}
mle <- gev_fit(x)$mle
Model <- portpirie %>% select(SeaLevel) %>% mutate(Model=GEV(z=SeaLevel,mle=mle))
Empirical <- portpirie %>% select(SeaLevel) %>% arrange(SeaLevel) %>% mutate(Empirical=row_number()/(nrow(portpirie)+1)) 
df <- portpirie %>% left_join(Empirical,by="SeaLevel") %>% left_join(Model,by="SeaLevel")
df %>% head()
df %>% ggplot()  + geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), color = "#C11432",size=1.5)+ geom_point(aes(x=Empirical,y=Model)) + ggtitle("Probability Plot") + xlab("Empirical distribution") + ylab("Model distribution")
```
Next is Q-Q plot.Q-Q plot compares two probability distributions by plotting their quantiles. In this example, it plots two GEV distributions with different parameters: empirical calculated though a formula used for the initial parameters in the optimisation and the model parameters (MLE).

```{r}
GEV_QQ <- function(x) {
  
# empirical distribution estimates
    sig_init <- sqrt(6 * var(x))/pi
    mu_init <- mean(x) - 0.57722 * sig_init
    xi_init <- 0.1
est_par <- c(mu_init,sig_init,xi_init)
# model (MLE) estimates
model_par <- gev_fit(x)$mle
# generate z using PIT for each case
q <- seq(from=1/(length(x)+1),to=length(x)/(length(x)+1),length.out=length(x)) #quantile
model <- GEV_inv(U=q,mle=model_par) #z generated from the model
est <- GEV_inv(U=q,mle=est_par) #z generated from GEV empirical estimates
dat <- x %>% sort()
return(data.frame(q=q,Model=model,Empirical=est,Data=dat))
}
# plot
df <- GEV_QQ(portpirie[,2])
df %>% head()
df %>% ggplot()  + 
  geom_segment(aes(x = 3.5, y = 3.5, xend = 4.9, yend = 4.9), color = "#C11432",size=1.5,alpha=0.5)+
  geom_point(aes(x=Empirical,y=Model)) + ggtitle("Q-Q Plot (from empirical estimates, not data)") + xlab("Empirical") + ylab("Model") 
```
The plot shows that empirical estimates are good since it is almost linear but shape parameter is a bit off, hence the slight curve. 

```{r}
df %>% ggplot()  + 
  geom_segment(aes(x = 3.5, y = 3.5, xend = 4.75, yend = 4.75), color = "#C11432",size=1.5,alpha=0.5)+
  geom_point(aes(y=Data,x=Model)) + ggtitle("Quantile Plot ") + ylab("Empirical") + xlab("Model")
```
The next plot is return level plot.

```{r}

```


