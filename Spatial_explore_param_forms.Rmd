---
title: "Exploration of potential parametric forms of conditional extreme value models"
output: html_document
date: "2024-10-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
library(MASS)
library(tidyverse)
library(latex2exp)
library(viridis)
library(plgp)
library(gridExtra)
library(here)
library(tmap)
library(units)
library(sf)
file.sources = list.files(pattern="*helpers.R")
sapply(file.sources,source,.GlobalEnv)
source("rotate_unrotate_coordinates.R")
gr_npole_lat <- 37.5
gr_npole_lon <- 177.5
load("spatialobjects.RData") # uk polygon and uk_temp_sf points sf objects
theme_set(theme_bw())
theme_replace(
  panel.spacing = unit(2, "lines"),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  strip.background = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA) )
```

## Set-up

Currently, we work with 19 years of daily maximum temperature data over summer months (June, July, August). (The issue with year 20 remains unresolved.)

```{r, include=FALSE}
# UKCP 18 data (summer max daily temperatures 1999-2018) ----
ukcp18 <- readRDS("data/uk_1999_2018_summer.RDS") %>% relocate(dist_london,.after=dist_glasgow)
# remove last year of the data due to error (same data as first year)
ukcp18 <- ukcp18[,1:1716]
conv <- CnvRttPol(latlon = data.frame(long=ukcp18$Longitude,lat=ukcp18$Latitude),spol_coor = c(gr_npole_lon, gr_npole_lat))
uk_sf_rot <- data.frame(lon=conv$lon,lat=conv$lat) %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326)
uk_sf_rot <- st_transform(uk_sf_rot,27700)
# add buffer
uk_buffered <- st_buffer(uk, 50000)   
# polygon of only the buffer
buffer_only <- st_difference(uk_buffered, uk) 
tm_shape(buffer_only) + tm_polygons()
coast_dist <- st_distance(uk_sf_rot,buffer_only)
uk_sf_rot <- cbind(uk_sf_rot,data.frame("coast_dist" = coast_dist))
tm_shape(uk_sf_rot) + tm_dots("coast_dist",size=1)
ukcp18 <- ukcp18 %>% mutate("Longitude" = conv$lon, "Latitude" = conv$lat, "coast_dist" = uk_sf_rot$coast_dist) %>% relocate(coast_dist,.before = dist_birmingham)
sims <- ukcp18 %>% dplyr::arrange(is_location)%>% dplyr::select(!contains("i")) %>% t() %>% as.data.frame()
# ordered alphabetically so Y1 Birmingham, Y2 Glasgow and Y3 is London
colnames(sims) <- paste0("Y",1:ncol(sims))
# transform to Laplace margins
sims <- as.data.frame((sims %>% apply(c(2),FUN=row_number))/(nrow(sims)+1)) %>% apply(c(1,2),FUN=unif_laplace_pit) %>% as.data.frame()
# calculate the residuals for Birmingham (1), then Glasgow (2) and London (3)
sites <- c("Birmingham","Glasgow","London")

```

## Follow-up from meeting with Simon: exploring $\alpha$ against distance

Recall the plot of marginal estimates of $\alpha$ parameter againt distance[m] for the three conditioning sites. This is done using the sequential method (see below).

```{r, echo=FALSE}
# use parameteric form for a ----
# calculate distance from the 3 conditioning sites
# transform dataframe to include a vector of x (temperature) and d (distance from the conditioning site)
# p <- list()
# x <- list()
# d <- list()
# for (i in 1:3) {
#   cond_var <- i
# x[[i]] <- par_est(sims,v=0.9,given=c(cond_var),margin = "AGG", method="sequential")$a
# d[[i]] <- (ukcp18 %>% arrange(is_location))[-cond_var,] %>% select(4+cond_var) %>% pull() %>% units::drop_units()
# opt <- optim(par=c(0.01,0.1),fn=NLL_exp_norm_noise,x=x[[i]],d=d[[i]])
# # plot a function of alpha against distance
# a <- exp(-opt$par[1]*d[[i]])
# p[[i]] <- ggplot() + geom_line(data=data.frame(x=d[[i]],y=a),aes(x=x,y=y)) +
#   geom_point(data=data.frame(x=d[[i]],y=x[[i]]),aes(x=x,y=y)) +
#   ylab(TeX("$\\alpha$")) + xlab("Distance")
# }
# save(p,x,d,file = "alphaspatial.RData")
load("alphaspatial.RData")
```

```{r}
grid.arrange(p[[1]],p[[2]],p[[3]],ncol=3)
```

We look at Birmingham (left) and London (right).

```{r}
# pick a straight line as a divide: diff for each site 
is_above <- function(x,y) { y>(y2-y1)/(x2-x1)*(x-x1)+y1
}
# pick 2 points on a line for Birmingham
x1 <- 0
x2 <- 450000
y1 <- 1.2
y2 <- 0.25
cond_var <- 1
df <- data.frame(x=d[[cond_var]],y=x[[cond_var]],z=as.character(is_above(d[[cond_var]],x[[cond_var]])))
p1 <- ggplot(df) + 
  geom_segment(x=x1,y=y1,xend=x2,yend=y2) +
   geom_point(aes(x=x,y=y,colour=factor(z))) + 
   ylab(TeX("$\\alpha$")) + xlab("Distance") + scale_color_manual(values = c("black", "#C11432")) + ggtitle("Birmingham")
# pick 2 points on a line for Birmingham
x1 <- 0
x2 <- 450000
y1 <- 1.2
y2 <- 0.25
cond_var <- 3
df <- data.frame(x=d[[cond_var]],y=x[[cond_var]],z=as.character(is_above(d[[cond_var]],x[[cond_var]])))
p2 <- ggplot(df) + 
  geom_segment(x=x1,y=y1,xend=x2,yend=y2) +
   geom_point(aes(x=x,y=y,colour=factor(z))) + 
   ylab(TeX("$\\alpha$")) + xlab("Distance") + scale_color_manual(values = c("black", "#C11432")) + ggtitle("London")
# plot to check Birmingham and London
grid.arrange(p1,p2,ncol=2)
```
Link both back to spatial locations to explore any potential patterns.
```{r}
cond_var <- 1
df1 <- data.frame(is_above = factor( as.character(is_above(d[[cond_var]],x[[cond_var]])))) %>%  add_row(.before=cond_var)
cond_var <- 3
df3 <- data.frame(is_above = factor( as.character(is_above(d[[cond_var]],x[[cond_var]])))) %>%  add_row(.before=cond_var)
uk_tmp <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8]) %>% 
  arrange(is_location) 
tmp1 <- uk_tmp %>% cbind(df1)
tmp3 <- uk_tmp %>% cbind(df3)
tmap_arrange(tm_shape(tmp1) + tm_dots(col="is_above",size=0.3,palette=c("TRUE" = "#C11432", "FALSE" = "black")) + tm_layout(main.title="Birmingham"), tm_shape(tmp3) + tm_dots(col="is_above",size=0.3,palette=c("TRUE" = "#C11432", "FALSE" = "black")) + tm_layout(main.title="London"), ncol=2 )
```
Both conditioning sites show a similar pattern, which suggest higher dependence decay with distance (black) in the south of the mainland UK and in the vicinity of the conditioning sites. The dividing line could be moved to explore this result further.

## Sequential parameter estimation

1. Fix $\beta=0$, estimate $\hat{\alpha}$.
2. Fix $\alpha=\hat{\alpha}$, estimate $\hat{\beta}$.
3. Fix $\alpha=\hat{\alpha}$ and $\beta=\hat{\beta}$, estimate $\hat{\mu}$ and $\hat{\sigma}$.
4. Calculate observed residuals, estimate $\hat{\mu}_{AGG}$, $\hat{\sigma}_{AGG}$, $\hat{\delta}_l$ and $\hat{\delta}_u$.

```{r, include=FALSE}
# function for plotting parameter estimates on a map and against distance
plot_map_param <- function(tmp_est1,tmp_est2,tmp_est3) {
  cond_var <- 1
 tmp <- tmp_est1 %>% mutate(given=factor(given,levels = cond_var))
tmp1 <- tmp %>% add_row(.before=cond_var)
# match back to spatial locations and plot
uk_tmp1 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8]) %>% 
  arrange(is_location) %>% cbind(tmp1) 
cond_var <- 2
 tmp <- tmp_est2 %>% mutate(given=factor(given,levels = cond_var))
tmp1 <- tmp %>% add_row(.before=cond_var)
# match back to spatial locations and plot
uk_tmp2 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8]) %>% 
  arrange(is_location) %>% cbind(tmp1) 
cond_var <- 3
 tmp <- tmp_est3 %>% mutate(given=factor(given,levels = cond_var))
tmp1 <- tmp %>% add_row(.before=cond_var)
# match back to spatial locations and plot
uk_tmp3 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8]) %>% 
  arrange(is_location) %>% cbind(tmp1) 

pa <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="a",style="cont",size=0.3,palette="viridis",title=TeX("$\\alpha$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="a",style="cont",size=0.3,palette="viridis",title=TeX("$\\alpha$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="a",style="cont",size=0.3,palette="viridis",title=TeX("$\\alpha$")) + tm_layout(main.title="London"),ncol=3)

pb <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="b",style="cont",size=0.3,palette="viridis",title=TeX("$\\beta$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="b",style="cont",size=0.3,palette="viridis",title=TeX("$\\beta$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="b",style="cont",size=0.3,palette="viridis",title=TeX("$\\beta$")) + tm_layout(main.title="London"),ncol=3)

pmu <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="mu",style="cont",size=0.3,palette="viridis",title=TeX("$\\mu$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="mu",style="cont",size=0.3,palette="viridis",title=TeX("$\\mu$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="mu",style="cont",size=0.3,palette="viridis",title=TeX("$\\mu$")) + tm_layout(main.title="London"),ncol=3)

psig <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="sig",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="sig",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="sig",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma$")) + tm_layout(main.title="London"),ncol=3)

pmuagg <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="mu_agg",style="cont",size=0.3,palette="viridis",title=TeX("$\\mu_{AGG}$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="mu_agg",style="cont",size=0.3,palette="viridis",title=TeX("$\\mu_{AGG}$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="mu_agg",style="cont",size=0.3,palette="viridis",title=TeX("$\\mu_{AGG}$")) + tm_layout(main.title="London"),ncol=3)

psigl <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="sigl",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma_l$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="sigl",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma_l$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="sigl",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma_l$")) + tm_layout(main.title="London"),ncol=3)

psigu <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="sigu",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma_u$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="sigu",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma_u$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="sigu",style="cont",size=0.3,palette="viridis",title=TeX("$\\sigma_u$")) + tm_layout(main.title="London"),ncol=3)

pdeltal <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="deltal",style="cont",size=0.3,palette="viridis",title=TeX("$\\delta_l$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="deltal",style="cont",size=0.3,palette="viridis",title=TeX("$\\delta_l$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="deltal",style="cont",size=0.3,palette="viridis",title=TeX("$\\delta_l$")) + tm_layout(main.title="London"),ncol=3)

pdeltau <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="deltau",style="cont",size=0.3,palette="viridis",title=TeX("$\\delta_u$")) + tm_layout(main.title="Birmingham"),
             tm_shape(uk_tmp2) + tm_dots(col="deltau",style="cont",size=0.3,palette="viridis",title=TeX("$\\delta_u$")) + tm_layout(main.title="Glasgow"),tm_shape(uk_tmp3) + tm_dots(col="deltau",style="cont",size=0.3,palette="viridis",title=TeX("$\\delta_u$")) + tm_layout(main.title="London"),ncol=3)
return(list(pa,pb,pmu,psig,pmuagg,psigl,psigu,pdeltal,pdeltau))
}
```

```{r, echo=FALSE}
# plot parameter estimates against distance and on a map
# cond_var <- 1
# tmp_est1 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
# cond_var <- 2
# tmp_est2 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
# cond_var <- 3
# tmp_est3 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
# save these objects for faster knitting
# save(uk,uk_temp_sf,tmp_est1,tmp_est2,tmp_est3,file = "spatialobjects.RData")
#plot_dist_param(site1=tmp_est1,site2=tmp_est2,site3=tmp_est3)
plot_map_param(tmp_est1=tmp_est1,tmp_est2=tmp_est2,tmp_est3=tmp_est3)
```

Now, the same approach with alpha values on the fitted exponential curve with distance.

1. Fix $\beta=0$, estimate $\hat{\alpha}$.
2. Fix $\alpha=\hat{\alpha}$, estimate $\hat{\beta}$.
3. Fix $\alpha=\hat{\alpha}$ and $\beta=\hat{\beta}$, estimate $\hat{\mu}$ and $\hat{\sigma}$.
4. Calculate observed residuals, estimate $\hat{\mu}_{AGG}$, $\hat{\sigma}_{AGG}$, $\hat{\delta}_l$ and $\hat{\delta}_u$.

## Conditioning on any random site

Currently, the analysis is conditioning on Birmingham, Glasgow and London, ordered as first 3 columns of the temperature data for an easy link. 

```{r, include=FALSE}

```