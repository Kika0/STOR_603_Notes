---
title: "Exploration of potential parametric forms of conditional extreme value models"
output: html_document
date: "2024-10-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE)
library(MASS)
library(tidyverse)
library(latex2exp)
library(viridis)
library(plgp)
library(gridExtra)
library(here)
library(tmap)
library(units)
library(RColorBrewer)
library(sf)
file.sources = list.files(pattern="*helpers.R")
sapply(file.sources,source,.GlobalEnv)
source("rotate_unrotate_coordinates.R")
gr_npole_lat <- 37.5
gr_npole_lon <- 177.5
load("spatialobjects.RData") # uk polygon and uk_temp_sf points sf objects
theme_set(theme_bw())
theme_replace(
  panel.spacing = unit(2, "lines"),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  strip.background = element_blank(),
  panel.border = element_rect(colour = "black", fill = NA) )
```

## Set-up

Currently, we work with 19 years of daily maximum temperature data over summer months (June, July, August). (The issue with year 20 remains unresolved.)

```{r, include=FALSE}
# UKCP 18 data (summer max daily temperatures 1999-2018) ----
ukcp18 <- readRDS("data/uk_1999_2018_summer.RDS") %>% relocate(dist_london,.after=dist_glasgow)
# remove last year of the data due to error (same data as first year)
ukcp18 <- ukcp18[,1:1716]
conv <- CnvRttPol(latlon = data.frame(long=ukcp18$Longitude,lat=ukcp18$Latitude),spol_coor = c(gr_npole_lon, gr_npole_lat))
uk_sf_rot <- data.frame(lon=conv$lon,lat=conv$lat,ind=conv$ind) %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326)
uk_sf_rot <- st_transform(uk_sf_rot,27700) %>% mutate(lon=conv$lon,lat=conv$lat)
# add buffer
uk_buffered <- st_buffer(uk, 50000)   
# polygon of only the buffer
buffer_only <- st_difference(uk_buffered, uk) 
tm_shape(buffer_only) + tm_polygons()
coast_dist <- st_distance(uk_sf_rot,buffer_only)
uk_sf_rot <- cbind(uk_sf_rot,data.frame("coast_dist" = coast_dist))
tm_shape(uk_sf_rot) + tm_dots("coast_dist",size=1)
ukcp18 <- ukcp18 %>% mutate("Longitude_conv" = conv$lon, "Latitude_conv" = conv$lat, "coast_dist" = uk_sf_rot$coast_dist) %>% relocate(coast_dist,.before = dist_birmingham) %>% relocate(c(Longitude_conv,Latitude_conv),.before = is_location)
sims <- ukcp18 %>% dplyr::arrange(is_location)%>% dplyr::select(!contains("i")) %>% t() %>% as.data.frame()
# ordered alphabetically so Y1 Birmingham, Y2 Glasgow and Y3 is London
colnames(sims) <- paste0("Y",1:ncol(sims))
# transform to Laplace margins
sims <- as.data.frame((sims %>% apply(c(2),FUN=row_number))/(nrow(sims)+1)) %>% apply(c(1,2),FUN=unif_laplace_pit) %>% as.data.frame()
# calculate the residuals for Birmingham (1), then Glasgow (2) and London (3)
sites <- c("Birmingham","Glasgow","London")
```

## Follow-up from meeting with Simon: exploring $\alpha$ against distance

Recall the plot of marginal estimates of $\alpha$ parameter against distance[m] for the three conditioning sites. This is done using the sequential method (see below).

```{r, echo=FALSE}
# use parameteric form for a ----
# calculate distance from the 3 conditioning sites
# transform dataframe to include a vector of x (temperature) and d (distance from the conditioning site)
# p <- list()
# x <- list()
# d <- list()
# for (i in 1:3) {
#   cond_var <- i
# x[[i]] <- par_est(sims,v=0.9,given=c(cond_var),margin = "AGG", method="sequential")$a
# d[[i]] <- (ukcp18 %>% arrange(is_location))[-cond_var,] %>% select(4+cond_var) %>% pull() %>% units::drop_units()
# opt <- optim(par=c(0.01,0.1),fn=NLL_exp_norm_noise,x=x[[i]],d=d[[i]])
# # plot a function of alpha against distance
# a <- exp(-opt$par[1]*d[[i]])
# p[[i]] <- ggplot() + geom_line(data=data.frame(x=d[[i]],y=a),aes(x=x,y=y)) +
#   geom_point(data=data.frame(x=d[[i]],y=x[[i]]),aes(x=x,y=y)) +
#   ylab(TeX("$\\alpha$")) + xlab("Distance")
# }
# save(p,x,d,file = "alphaspatial.RData")
load("alphaspatial.RData")
```

```{r}
grid.arrange(p[[1]],p[[2]],p[[3]],ncol=3)
```

We look at Birmingham (left) and London (right).

```{r}
# pick a straight line as a divide using 2 points: diff for each site 
is_above <- function(x,y,x1,x2,y1,y2) { y>(y2-y1)/(x2-x1)*(x-x1)+y1
}
plot_is_above <- function(x1,x2,y1,y2,cond_var) {
sites <- c("Birmingham", "Glasgow", "London")
df <- data.frame(x=d[[cond_var]],y=x[[cond_var]],z=as.character(is_above(d[[cond_var]],x[[cond_var]],x1=x1,x2=x2,y1=y1,y2=y2)))
p <- ggplot(df) + 
  geom_segment(x=x1,y=y1,xend=x2,yend=y2) +
   geom_point(aes(x=x,y=y,colour=factor(z))) + 
   ylab(TeX("$\\alpha$")) + xlab("Distance") + scale_color_manual(values = c("black", "#C11432")) + ggtitle(sites[cond_var])
return(p)
}
# plot to check Birmingham, Glasgow and London
p1 <- plot_is_above(x1=0,x2=450000,y1=1.2,y2=0.25,cond_var=1)
p2 <- plot_is_above(x1=0,x2=450000,y1=1.2,y2=0.25,cond_var=2)
p3 <- plot_is_above(x1=0,x2=450000,y1=1.2,y2=0.25,cond_var=3)
grid.arrange(p1,p2,p3,nrow=3)
```

Link both back to spatial locations to explore any potential patterns.

```{r, warning=FALSE}
map_is_above <- function(x1,x2,y1,y2,cond_var) {
  sites <- c("Birmingham", "Glasgow", "London")
  df <- data.frame(is_above = factor( as.character(is_above(d[[cond_var]],x[[cond_var]],x1=x1,x2=x2,y1=y1,y2=y2)))) %>%  add_row(.before=cond_var)
uk_tmp <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8]) %>% 
  arrange(is_location) 
tmp1 <- uk_tmp %>% cbind(df)
tm_shape(tmp1) + tm_dots(col="is_above",size=0.3,palette=c("TRUE" = "#C11432", "FALSE" = "black")) + tm_layout(main.title=sites[cond_var])
}
p1 <- map_is_above(x1=0,x2=450000,y1=1.2,y2=0.25,cond_var=1)
p2 <- map_is_above(x1=0,x2=450000,y1=1.2,y2=0.25,cond_var=2)
p3 <- map_is_above(x1=0,x2=450000,y1=1.2,y2=0.25,cond_var=3)
tmap_arrange(p1,p2,p3,ncol=3)
```

Birmingham and London show a similar pattern, which suggest higher dependence decay with distance (black) in the south of the mainland UK and in the vicinity of the conditioning sites. The dividing line could be moved to explore this result further.

## Sequential parameter estimation

1.  Fix $\beta=0$, estimate $\hat{\alpha}$.
2.  Fix $\alpha=\hat{\alpha}$, estimate $\hat{\beta}$.
3.  Fix $\alpha=\hat{\alpha}$ and $\beta=\hat{\beta}$, estimate $\hat{\mu}$ and $\hat{\sigma}$.
4.  Calculate observed residuals, estimate $\hat{\mu}_{AGG}$, $\hat{\sigma}_{AGG}$, $\hat{\delta}_l$ and $\hat{\delta}_u$.

```{r, include=FALSE}
# function for plotting parameter estimates on a map and against distance
plot_map_param <- function(tmp_est1,tmp_est2,tmp_est3,method = "AGG",threesites=c("Birmingham","Glasgow","London"), indeces=1:3) {
misscol <- "aquamarine"
cond_var <- indeces[1]
tmp <- tmp_est1 %>% mutate(given=factor(cond_var,levels = cond_var)) 
tmp1 <- tmp %>% add_row(.before=cond_var)
# match back to spatial locations and plot
if (identical(indeces,1:3)) {
uk_tmp1 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8]) %>% 
  arrange(is_location) %>% cbind(tmp1)
}
else {uk_tmp1 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8])  %>% cbind(tmp1) }
if (method=="AGG") {
uk_tmp1 <- uk_tmp1 %>% mutate(sigdiff=sigu-sigl) %>% mutate(deltadiff=deltau-deltal)
}

cond_var <- indeces[2]
 tmp <- tmp_est2 %>% mutate(given=factor(cond_var,levels = cond_var))
tmp1 <- tmp %>% add_row(.before=cond_var)
# match back to spatial locations and plot
if (identical(indeces,1:3)) {
uk_tmp2 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8]) %>% 
  arrange(is_location) %>% cbind(tmp1)
}
else {uk_tmp2 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8])  %>% cbind(tmp1) }
if (method=="AGG") {
uk_tmp2 <- uk_tmp2 %>% mutate(sigdiff=sigu-sigl) %>% mutate(deltadiff=deltau-deltal)
}
cond_var <- indeces[3]
 tmp <- tmp_est3 %>% mutate(given=factor(cond_var,levels = cond_var))
tmp1 <- tmp %>% add_row(.before=cond_var)
# match back to spatial locations and plot
if (identical(indeces,1:3)) {
uk_tmp3 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8]) %>% 
  arrange(is_location) %>% cbind(tmp1)
}
else {uk_tmp3 <- uk_temp_sf %>% dplyr::select() %>% cbind(ukcp18[,1:8])  %>% cbind(tmp1) }
if (method=="AGG") {
uk_tmp3 <- uk_tmp3 %>% mutate(sigdiff=sigu-sigl) %>% mutate(deltadiff=deltau-deltal)
}

lims <- seq(min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$a),na.rm = TRUE),max(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$a),na.rm = TRUE),length.out=5)
pa <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="a",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\alpha$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2) + tm_dots(col="a",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\alpha$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3) + tm_dots(col="a",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\alpha$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)
 if (method=="AGG") {
lims <- seq(min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$b),na.rm = TRUE),max(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$b),na.rm = TRUE),length.out=6)
pb <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="b",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\beta$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2) + tm_dots(col="b",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\beta$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3) + tm_dots(col="b",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\beta$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)
}
lims <- seq(min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$mu),na.rm = TRUE),max(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$mu),na.rm = TRUE),length.out=6)
pmu <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="mu",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\mu$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2) + tm_dots(col="mu",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\mu$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3) + tm_dots(col="mu",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\mu$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3) 

sigmax <- 3
lims <- seq(min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$sig),na.rm = TRUE),min(max(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$sig),na.rm = TRUE),sigmax),length.out=6)
psig <- tmap_arrange(tm_shape(uk_tmp1 %>% filter(is.na(sig) |sig < sigmax)) + tm_dots(col="sig",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2 %>% filter(is.na(sig) |sig < sigmax)) + tm_dots(col="sig",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3 %>% filter( is.na(sig) | sig < sigmax)) + tm_dots(col="sig",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)
if (method=="AGG") {
lims <- seq(min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$mu_agg),na.rm = TRUE),max(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$mu_agg),na.rm = TRUE),length.out=6)
pmuagg <- tmap_arrange(tm_shape(uk_tmp1) + tm_dots(col="mu_agg",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\mu_{AGG}$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2) + tm_dots(col="mu_agg",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\mu_{AGG}$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3) + tm_dots(col="mu_agg",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\mu_{AGG}$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)

lims <- seq(min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$sigl),na.rm = TRUE),sigmax,length.out=6)
psigl <- tmap_arrange(tm_shape(uk_tmp1 %>% filter(is.na(sigl) | sigl < sigmax)) + tm_dots(col="sigl",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma_l$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2 %>% filter(is.na(sigl) |sigl < sigmax)) + tm_dots(col="sigl",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma_l$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3 %>% filter(is.na(sigl) |sigl < sigmax)) + tm_dots(col="sigl",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma_l$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)

lims <- seq(min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$sigu),na.rm = TRUE),sigmax,length.out=6)
psigu <- tmap_arrange(tm_shape(uk_tmp1 %>% filter(is.na(sigu) | sigu < sigmax)) + tm_dots(col="sigu",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma_u$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2 %>% filter(is.na(sigu) |sigu < sigmax)) + tm_dots(col="sigu",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma_u$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3 %>% filter(is.na(sigu) |sigu < sigmax)) + tm_dots(col="sigu",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\sigma_u$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)

lims <- seq(min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$sigdiff),na.rm = TRUE),sigmax,length.out=6)
psigdiff <- tmap_arrange(tm_shape(uk_tmp1 %>% filter(is.na(sigdiff) | sigdiff < sigmax)) + tm_dots(col="sigdiff",style="cont",size=0.3,palette="-RdBu",midpoint=0,colorNA=misscol,title=TeX("$\\sigma_u-\\sigma_l$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2 %>% filter(is.na(sigdiff) |sigdiff < sigmax)) + tm_dots(col="sigdiff",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\sigma_u-\\sigma_l$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3 %>% filter(is.na(sigdiff) |sigdiff < sigmax)) + tm_dots(col="sigdiff",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\sigma_u-\\sigma_l$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)

deltamax <- 5
deltamin <- min(as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$deltal),as.numeric(rbind(uk_tmp1,uk_tmp2,uk_tmp3)$deltau),na.rm = TRUE)
lims <- seq(deltamin,deltamax,length.out=6)
pdeltal <- tmap_arrange(tm_shape(uk_tmp1 %>% filter(is.na(deltal)| deltal < deltamax)) + tm_dots(col="deltal",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\delta_l$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2 %>% filter(is.na(deltal)| deltal < deltamax)) + tm_dots(col="deltal",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\delta_l$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3 %>% filter(is.na(deltal)| deltal < deltamax)) + tm_dots(col="deltal",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\delta_l$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)

lims <- seq(deltamin,deltamax,length.out=6)
pdeltau <- tmap_arrange(tm_shape(uk_tmp1 %>% filter(is.na(deltau) | deltau < deltamax)) + tm_dots(col="deltau",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\delta_u$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2 %>% filter(is.na(deltau) |deltau < deltamax)) + tm_dots(col="deltau",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\delta_u$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3 %>% filter(is.na(deltau) |deltau < deltamax)) + tm_dots(col="deltau",style="cont",size=0.3,palette="viridis",colorNA=misscol,title=TeX("$\\delta_u$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)

deltamin <- -5
lims <- seq(deltamin,deltamax,length.out=6)
pdeltadiff <- tmap_arrange(tm_shape(uk_tmp1 %>% filter(is.na(deltadiff ) | (deltadiff < deltamax&deltadiff>deltamin))) + tm_dots(col="deltadiff",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\delta_u-\\delta_l$"), breaks=lims) + tm_layout(main.title=threesites[1]),
             tm_shape(uk_tmp2 %>% filter(is.na(deltadiff ) | (deltadiff < deltamax&deltadiff>deltamin))) + tm_dots(col="deltadiff",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\delta_u-\\delta_l$"), breaks=lims) + tm_layout(main.title=threesites[2]),tm_shape(uk_tmp3 %>% filter(is.na(deltadiff ) | (deltadiff < deltamax&deltadiff>deltamin))) + tm_dots(col="deltadiff",style="cont",size=0.3,palette="-RdBu",colorNA=misscol,midpoint=0,title=TeX("$\\delta_u-\\delta_l$"), breaks=lims) + tm_layout(main.title=threesites[3]),ncol=3)
return(list(pa,pb,pmu,psig,pmuagg,psigl,psigu,psigdiff,pdeltal,pdeltau,pdeltadiff)) 
}
if (method!="AGG") {return(list(pa,pmu,psig))}
}
```

```{r, echo=FALSE}
# v <- 0.9
# cond_var <- 1
# tmp_est1 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
# cond_var <- 2
# tmp_est2 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
# cond_var <- 3
# tmp_est3 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
# save these objects for faster knitting
# save(uk,uk_temp_sf,tmp_est1,tmp_est2,tmp_est3,file = "spatialobjects.RData")
#plot_dist_param(site1=tmp_est1,site2=tmp_est2,site3=tmp_est3)
plot_map_param(tmp_est1=tmp_est1,tmp_est2=tmp_est2,tmp_est3=tmp_est3)
```

Now, the same approach with alpha values on the fitted exponential curve with distance, so we use estimates of $\hat{\alpha}$ to fit an exponential curve to as a function of distance of site $i$ from the conditioning site $j$.

1.  Fix $\alpha=\alpha \left( d_{ij} \right) = \exp \left\{ - \phi d_{ij} \right\}$, estimate $\hat{\beta}$.
2.  Fix $\alpha=\alpha \left( d_{ij} \right)$ and $\beta=\hat{\beta}$, estimate $\hat{\mu}$ and $\hat{\sigma}$.
3.  Calculate observed residuals, estimate $\hat{\mu}_{AGG}$, $\hat{\sigma}_{AGG}$, $\hat{\delta}_l$ and $\hat{\delta}_u$.

```{r, echo=FALSE}
# plot parameter estimates against distance and on a map
# cond_var <- 1
# opt <- optim(par=c(0.01,0.1),fn=NLL_exp_norm_noise,x=x[[cond_var]],d=d[[cond_var]])
# tmp_est1a <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential3", a=exp(-opt$par[1]*d[[cond_var]]))
# cond_var <- 2
# opt <- optim(par=c(0.01,0.1),fn=NLL_exp_norm_noise,x=x[[cond_var]],d=d[[cond_var]])
# tmp_est2a <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential3", a=exp(-opt$par[1]*d[[cond_var]]))
# cond_var <- 3
# opt <- optim(par=c(0.01,0.1),fn=NLL_exp_norm_noise,x=x[[cond_var]],d=d[[cond_var]])
# tmp_est3a <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential3",a=exp(-opt$par[1]*d[[cond_var]]))
# # save these objects for faster knitting
# save(uk,uk_temp_sf,tmp_est1,tmp_est2,tmp_est3,tmp_est1a,tmp_est2a,tmp_est3a,file = "spatialobjects.RData")
plot_map_param(tmp_est1=tmp_est1a,tmp_est2=tmp_est2a,tmp_est3=tmp_est3a)
```

We can observe that imposing a parametric form on $\hat{\alpha}$ that only changes with distance leads to some unexpected values of $\hat{\beta}$ close to $1$. For the AGG distribution estimates, $\hat{\mu}_{AGG}$ is the mode of the distribution whereas $\hat{\mu}$ is the median as well as the mode for the symmetric Gaussian distribution. Therefore, lower values for $\hat{\mu}_{AGG}$ suggest heavier tails for the upper tail of the distribution. This is also shown by a positive difference of $\hat{\sigma}_u-\hat{\sigma}_l$.

## New iterative approach

```{r, echo=FALSE}
v <- 0.9
sims <- ukcp18 %>% dplyr::select(!contains("i")) %>% t() %>% as.data.frame()
colnames(sims) <- paste0("Y",1:ncol(sims))
# transform to Laplace margins
sims <- as.data.frame((sims %>% apply(c(2),FUN=row_number))/(nrow(sims)+1)) %>% apply(c(1,2),FUN=unif_laplace_pit) %>% as.data.frame()
# find site closest to a vector of lon lat coordinates
find_site_index <- function(site = Inverness,grid_uk = uk_sf_rot %>% select()) {
  # convert site coordinates
site_sf <- st_sfc(st_point(site),crs=4326) 
site_sf <- st_transform(site_sf, crs=27700) # set BNG crs
x <- which.min(as.numeric(st_distance(site_sf,grid_uk)))
# check it works
#return(tm_shape(uk_sf_rot) + tm_dots() + tm_shape(site_sf) + tm_dots(col="#C11432") + tm_shape(uk_sf_rot[x,])+ tm_dots(col="#009ADA"))
return(x)
}

Birmingham <- c(-1.9032,52.4806)
Glasgow <- c(-4.258109,55.859112)
London <- c(-0.127676,51.529972)
```

```{r}
# cond_site <- find_site_index(Birmingham)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite1 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = 10, show_ite = TRUE)
# 
# cond_site <- find_site_index(Glasgow)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite2 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = 10, show_ite = TRUE)
# 
# cond_site <- find_site_index(London)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite3 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = 10, show_ite = TRUE)
```

First, we plot the iterations of parameter estimates to check convergence.

```{r}
plot_par_est_ite <- function(newite,pick_site=100) {
df <- data.frame("a"=as.numeric(newite[[1]][pick_site,]), "mu" = as.numeric(newite[[2]][pick_site,]), "sig" = as.numeric(newite[[3]][pick_site,]), "index" = 0:(ncol(newite[[1]])-1))
p1 <- ggplot(df) + geom_point(aes(x=index,y=a)) + ylab(TeX("$\\alpha$"))
p2 <- ggplot(df) + geom_point(aes(x=index,y=mu)) + ylab(TeX("$\\mu$"))
p3 <- ggplot(df) + geom_point(aes(x=index,y=sig)) + ylab(TeX("$\\sigma$"))
return(grid.arrange(p1,p2,p3,ncol=3))
}
plot_par_est_ite(newite = newite1)
```

Repeat also for Glasgow.

```{r}
plot_par_est_ite(newite = newite2,pick_site = 50)
```

and London.

```{r}
plot_par_est_ite(newite = newite3)
```

Plot also on a map.
```{r}
plot_map_param(tmp_est1 = newite1[[4]], tmp_est2 = newite2[[4]], tmp_est3 = newite3[[4]],method= "iterative_alpha",threesites = c("Bimingham","Glasgow","London"),indeces=c(find_site_index(Birmingham),find_site_index(Glasgow),find_site_index(London)))
```

## Conditioning on any random site

Currently, the analysis is conditioning on Birmingham, Glasgow and London, ordered as first 3 columns of the temperature data for an easy link.

One way would be to calculate distance from each of the site and then filter distance for the site needed, which will be faster as this distance matrix will be already saved (twice as $d_{ij}$ and $d_{ji}$ are identical ).

We find the index of the grid sites closest to Inverness, Lancaster and Newcastle to get a better idea of potential parametric forms of the parameters.

```{r, include=FALSE}
Inverness <- c(-4.22498,57.48065) # Inverness bus station
Lancaster <- c(-2.78440,54.00871) # PSC building Lancaster University
Newcastle <- c(-1.61682,54.96902) # Newcastle railway station
```

## Sequential parameter estimation: other conditioning sites

We repeat the parameter estimation method described above for three other conditioning sites: Inverness, Lancaster and Newcastle.

```{r}
# v <- 0.9
# N <- 10
# sims <- ukcp18 %>% dplyr::select(!contains("i")) %>% t() %>% as.data.frame()
# colnames(sims) <- paste0("Y",1:ncol(sims))
# # transform to Laplace margins
# sims <- as.data.frame((sims %>% apply(c(2),FUN=row_number))/(nrow(sims)+1)) %>% apply(c(1,2),FUN=unif_laplace_pit) %>% as.data.frame()
# cond_site <- find_site_index(Inverness)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite4 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = N, show_ite = TRUE)
# 
# cond_site <- find_site_index(Lancaster)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite5 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = N, show_ite = TRUE)
# 
# cond_site <- find_site_index(Newcastle)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite6 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = N, show_ite = TRUE)
```

Examine similar plots of parameter estimate iterations for a randomly picked site $j$ (set to $j=100$).

Inverness:

```{r}
plot_par_est_ite(newite = newite4)
```

Lancaster:

```{r}
plot_par_est_ite(newite = newite5)
```

Newcastle:

```{r}
plot_par_est_ite(newite = newite6)
```

Similar to the previous section, we map the parameter estimates of the final iteration.

```{r}
plot_map_param(tmp_est1 = newite4[[4]], tmp_est2 = newite5[[4]], tmp_est3 = newite6[[4]],method= "iterative_alpha",threesites = c("Inverness","Lancaster","Newcastle"),indeces=c(find_site_index(Inverness),find_site_index(Lancaster),find_site_index(Newcastle)))
```

## Sequential parameter estimation: $3$ new sites

```{r, echo=FALSE}
# v <- 0.9
# cond_var <- find_site_index(Inverness)
# tmp_est4 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
# cond_var <- find_site_index(Lancaster)
# tmp_est5 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
# cond_var <- find_site_index(Newcastle)
# tmp_est6 <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential2")
#plot_dist_param(site1=tmp_est4,site2=tmp_est5,site3=tmp_est6)
plot_map_param(tmp_est1=tmp_est4,tmp_est2=tmp_est5,tmp_est3=tmp_est6,threesites = c("Inverness","Lancaster","Newcastle"),method="AGG",indeces=c(find_site_index(Inverness),find_site_index(Lancaster),find_site_index(Newcastle)))
```

Now fit exponential to $\alpha$ estimates and find MLE for the other parameters using the sequential approach.

```{r}
# plot parameter estimates against distance and on a map
# cond_var <- find_site_index(Inverness)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_var,],uk_sf_rot[-cond_var,]))
# opt <- optim(par=c(0.01,0.1),fn=NLL_exp_norm_noise,x=tmp_est4$a,d=dij)
# tmp_est4a <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential3", a=exp(-opt$par[1]*dij))
# 
# cond_var <- find_site_index(Lancaster)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_var,],uk_sf_rot[-cond_var,]))
# opt <- optim(par=c(0.01,0.1),fn=NLL_exp_norm_noise,x=tmp_est5$a,d=dij)
# tmp_est5a <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential3", a=exp(-opt$par[1]*dij))
# 
# cond_var <- find_site_index(Newcastle)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_var,],uk_sf_rot[-cond_var,]))
# opt <- optim(par=c(0.01,0.1),fn=NLL_exp_norm_noise,x=tmp_est6$a,d=dij)
# tmp_est6a <- par_est(sims,v=v,given=c(cond_var),margin = "AGGsigdelta", method="sequential3",a=exp(-opt$par[1]*dij))
# 

plot_map_param(tmp_est1=tmp_est4a,tmp_est2=tmp_est5a,tmp_est3=tmp_est6a,threesites = c("Inverness","Lancaster","Newcastle"),method="AGG",indeces=c(find_site_index(Inverness),find_site_index(Lancaster),find_site_index(Newcastle)))
```

## New sites: Cromer, Hull and Lowestoft

```{r}
Cromer <- c(1.28486,53.05349)
Hull <- c(-0.335827,53.767750)
Lowestoft <- c(1.72431,52.48435)
# v <- 0.9
# N <- 10
# 
# cond_site <- find_site_index(Cromer)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite7 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = N, show_ite = TRUE)
# 
# cond_site <- find_site_index(Hull)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite8 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = N, show_ite = TRUE)
# 
# cond_site <- find_site_index(Lowestoft)
# dij <- as.numeric(st_distance(uk_sf_rot[cond_site,],uk_sf_rot[-cond_site,]))
# newite9 <- par_est_ite(df = sims, d1j = dij, v = v, given = cond_site, N = N, show_ite = TRUE)

plot_map_param(tmp_est1 = newite7[[4]], tmp_est2 = newite8[[4]], tmp_est3 = newite9[[4]],method= "iterative_alpha",threesites = c("Cromer","Hull","Lowestoft"),indeces=c(find_site_index(Cromer),find_site_index(Hull),find_site_index(Lowestoft)))
```

```{r}
# # save these objects for faster knitting
# save(uk,uk_temp_sf,tmp_est1,tmp_est2,tmp_est3,tmp_est1a,tmp_est2a,tmp_est3a,tmp_est4,tmp_est5,tmp_est6,tmp_est4a,tmp_est5a,tmp_est6a,tmp_est7,tmp_est8,tmp_est9,tmp_est10,tmp_est11,tmp_est12,newite1,newite2,newite3,newite4,newite5,newite6,newite7,newite8,newite9,file = "spatialobjects.RData")

plot_map_param(tmp_est1=tmp_est7,tmp_est2=tmp_est8,tmp_est3=tmp_est9,threesites = c("Cromer","Hull","Lowestoft"),method="AGG",indeces=c(find_site_index(Cromer),find_site_index(Hull),find_site_index(Lowestoft)))
```


